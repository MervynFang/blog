[{"title":"双十一之后的变化","date":"2017-11-14T08:09:01.000Z","path":"2017/11/14/201711/doubleeleven/","text":"本文链接: http://blog.mervynfang.com/2017/11/14/201711/doubleeleven/ 又是一年双十一之后了。 今年的 1682 亿，比去年多出了 40%，多了将近 500 亿，这个增长比去年的还多，其实经济都是有迹可循的，在今年一直被吐槽规则复杂，困难群众的情况下，一下子就把购物车清空了。 股票市场现在是慢热之中，房市已经比较冷淡了，自然还是有点闲钱投入到购物之中。所谓的口红效应，自然不会出现。 这也是新零售，新消费的结果。随着智能手机的普及，更多的人适应了互联网的生活，并且在相应的广告宣传以及实在的打折之下，GMV 的确会被拉起来的。而且，随着时间的发展，特别是互联网金融的完善建设，更多的线上生活会成为现实。所以，在未来几年，双十一的销售额将会不断地上升，不过增速肯定会逐步下降的。 至于统计数学方便，由于电商可统计的维度实在是太多，大家都成为第一未免也不是一件坏事。 优衣库 725 的东西最后用 475 买下来了，嗯，还是比较满意的。相当于 65 折。主要是平时也是卖原价，不像某些东西都涨价后再下调，那就太没良心的。 至于什么购物津贴 bla bla 的，还有什么花呗盒子（最后抽到一张一元抵扣券看那页面似乎我中了 100 万一样），跟微信的红包店一样，呵呵一声就好。 天下武功，唯富不破。","tags":[{"name":"Daily","slug":"Daily","permalink":"//mervynfang.com/tags/Daily/"}]},{"title":"王者荣耀，那年花开月正圆以及High Sierra","date":"2017-09-30T02:52:33.000Z","path":"2017/09/30/201709/wzrynnhk/","text":"本文链接: http://blog.mervynfang.com/2017/09/30/201709/wzrynnhk/ 王者荣耀，确实是一个现象级的游戏，毋庸置疑。日活 8000 万，1 天皮肤流水 1.5 个亿，最近逼得马云也把阿里游戏独立成事业群了，并且把之前网易游戏的 COO 以及 云风给挖过去了，团队很强。也有人拿出阿里说不做游戏的事情出来说事，还有说 KPI 导向并不适合做游戏，阿里这么大一家公司，还是能够做好游戏的，但就像百度外卖进场一样，在行业巨头的面前，其实是很难的，需要很长的一段时间。腾讯游戏从 04 年的对站厅到现在的王者荣耀，并不是没有一段过程的。 王者荣耀这款现象级的 MOBA 游戏，其实也未能避免进入历史的车轮中。自身的努力很重要，但也要考虑到历史的行程。随着时间的发展，用户的新鲜感过去，新用户增长饱和以及一些新的游戏的冲击，王者荣耀总有一天会下来神坛的，但是，它已经在中国游戏的发展史上写下了一笔，浓墨重彩的。 历史就是这样，你再厉害，最后也不过变成史书上的一句话，但现在可能会变成百科继续流传下去。科技其实也能够改变历史的方式。但更多的其实也便消逝在历史的长河中，无烟无影。怎么突然感伤起来了。 听到王者荣耀也便比较早，玩的时候也便是 16 年 11 月了。那时候玩的人也便多了起来。对游戏还是有我自己的理解的，包括到现在的出装，战术，都知道一些。只是可能年纪大了吧，操作有时候更不上，更不喜欢那种匹配的算法，以及游戏中队友之间一些不好的体验，所以基本上都是中午的时间吃晚饭，五黑。段位也落在上赛季的铂金，这赛季的钻石，也因为这个赛季增加了一个段位吧，所以自己就上去了，看来自己的水平就是这样了。 英雄有 70 个，就差一个武则天，正在夺宝之中。铭文有 85 个，差不多三套吧，法师，射手，战士，暴击基本都有了，总共要做 10 套基本才适用所有的英雄。这种 10 套其实很多都是重叠的，其实三套我已经拆分成 8 套了，其实最后总共有差不多 140 个就够了，加多肉的，攻速和百穿，有强迫症的人总看不得缺少了哪一套铭文或者是混合用的，所以就想养成把它做好，其实也是很快的。 但素，最近确实也觉得很心累了，跟同事们也都觉得，本来一天高高兴兴，打了个游戏就不高兴了。本来为了快乐搞得不快乐，为什么人总这么傻呢。所以，也便没事开开黑，收集东西做做铭文，其实就够了。不然按我操作，差不多得上多一个大段位吧。但是，这种上上下下的，其实会让人心累的，所以为了保持快乐，还是不要打排位。4 个月，130 场，不多吧。而且玩五黑套路的，也挺难的，经常玩不过。 所以啊，弃坑是必然的，只是时间问题。 腾讯视频那年花开月正圆热播，前面看了几集，还不错，就继续看下来了，虽然剧本比较扯且虐心，虽然剧里莫名人就死了，但是，我是 VIP 啊。可以提前看两集，不错，不错。也通过这个去加快王者荣耀的弃坑过程吧。 不过演技也确实爆炸，不过想想，孙俪任重何润东，还有老戏骨们，这些都是多老的人了啊。还好陈晓比较年轻。想想现在的一些小鲜肉演的剧，根本就没法看，颜值确实高，但演技差啊。还有什么 PS 和一二三四五六七的，实在是太烂了。腾讯视频今年还有一部如懿传，周迅和霍建华主演，应该也是不错的。欢迎上腾讯视频观看，充个会员体验更佳哦。我个人应该是不会看的，对这种宫斗剧没啥感觉。 我的 Mac High Sierra 终于升级成功了，应该是苹果 CDN 放错文件了，大 Mac 比较后面下就没有问题，然后不断地去刷 CDN，小 Mac 的也顺利升级成功，没有兼容的问题，ioa 也能正常使用，这样最好了。上次出了个问题，导致这里我要谨慎点升级了。于是，就好好开发吧😂 ，不然还想怎样。 今天就是 9 月 30 日了，整个国庆假期最美好的一天。明天开始就要开始感叹假期一天比一天少了。珍惜时光吧。然后也好好休假。 祝双节快乐！","tags":[{"name":"Daily","slug":"Daily","permalink":"//mervynfang.com/tags/Daily/"},{"name":"Thinking","slug":"Thinking","permalink":"//mervynfang.com/tags/Thinking/"}]},{"title":"2017-09-27","date":"2017-09-27T09:08:39.000Z","path":"2017/09/27/201709/2017-09-27/","text":"本文链接: http://blog.mervynfang.com/2017/09/27/201709/2017-09-27/ macOS high sierra 也终于可以更新了，可惜啊，下载了不下 10 次了，仍然不能更新，包的大小仍然是尴尬的 4.69g。想着马上体验 APFS 也是不可能的啦，在更新本来就是鸡肋的同时，这无疑让人觉得心烦。只能抛开，待他日苹果更新了服务器的版本之后，再来更新下载吧。 你以为爱，就是被爱，你挥霍了我的崇拜。风筝有风，海豚有海，可我有什么？ 想想这歌词，确实挺心酸的。let it be。 时间也过得很快，一下子就到九月底了。Q3 也已经结束，即将 Q4。生活中会面临着很多的困难，有的时候会想，要是怎样怎样，怎样怎样，要是没有这个烦恼，要是事事顺心，那就好了。 可惜的事，往往都不是这样的，生活本来就是，复杂，心酸，难受。还好依然保持着炽热之心。之前楚楚也说，不知道为啥对别人好，别人却对你很冷淡。可是啊，不就是这样的吗，要是你爱我就好了，要是你喜欢我就好了，要是啥啥就好了。但确实没那么好，所谓，严于律己，宽以待人，本来也不想有所回报，又何必执着呢。 但行好事，莫问前程。 曾经我也能够用这句话来鞭策自己，自己也的确能够做到了。可是，谁的心不会动，这可是涉及到你的核心利益的。被爱的总是有恃无恐，一旦不被爱了，不被重视了，自然就有恐了。 一直想做一些改变，是时候了。 冬天都来了，似乎到了冬季的心情总没那么好，哈哈，可是想想，虽然生活中有那么多的不开心，失望，沮丧，但是，还是能作乐的。一切都没那么容易，但是，谁也不会离不开谁过不下去了。就像最近看的《那年花开月正圆》里面的周老四说的—— 其实我们所有人呐，都是过客，你看啊，夫妻，父女，君臣，早晚都得散，只不过是，早几天，晚几天罢了。就是因为，早晚都要散，所以啊，聚的时候，就要铆足了劲的开心，等到散了呢，谁也别惦记谁，各自往各自的下一站奔。再找，新的开心。 开心就好，开心就好。 所以，是时候了。","tags":[{"name":"Daily","slug":"Daily","permalink":"//mervynfang.com/tags/Daily/"},{"name":"Thinking","slug":"Thinking","permalink":"//mervynfang.com/tags/Thinking/"}]},{"title":"旅行的意义","date":"2017-08-30T07:12:48.000Z","path":"2017/08/30/201708/旅行的意义/","text":"本文链接: http://blog.mervynfang.com/2017/08/30/201708/%E6%97%85%E8%A1%8C%E7%9A%84%E6%84%8F%E4%B9%89/ 前些天在网易云音乐（讲到云音乐就想起上阵子因为版权的问题想弃用改回拥有这绿钻和付费音乐包的 QQ 音乐账号，但是过了一周还是把所有平台的都卸载了，然后继续用云音乐，实在是习惯了）听到一首带你去旅行，被欢快的节奏以及舒服的曲调所吸引。又想起从前的旅行的意义。 你看过了许多美景，你看过了许多美女 你品尝了夜的巴黎，你踏过下雪的北京 你累积了许多飞行，你用心挑选纪念品 你拥抱热情的岛屿，你埋葬记忆的土耳其 你离开我，就是旅行的意义","tags":[{"name":"Travel","slug":"Travel","permalink":"//mervynfang.com/tags/Travel/"}]},{"title":"【译】Node.js, TC-39, 和模块","date":"2017-08-17T03:40:40.000Z","path":"2017/08/17/201708/Node-js-TC-39-和模块/","text":"本文链接: http://blog.mervynfang.com/2017/08/17/201708/Node-js-TC-39-%E5%92%8C%E6%A8%A1%E5%9D%97/ 原文标题: Node.js, TC-39, and Modules 作者: James M Snell 原文链接: https://medium.com/hacker-daily/node-js-tc-39-and-modules-a1118aecf95e 这周我第一次参加 TC-39 会议。如果你没听说过 TC-39，这里可以简单解释下，TC-39 是 ECMA（欧洲计算机制造联合会）中 ECMAScript 语言（或者叫大家更为熟知的 Javascript）的标准制定委员会。在 TC-39 上，Javascript 语言标准的很多微小的细节实现和差异被定案，委员会致力于保持 Javascript 的持续发展以及给满足更多开发者的需求。 我这周参加 TC-39 会议的理由非常简单：一个 TC-39 定义的最新的 Javascript 语言标准，也就是 Modules，给 Node.js 核心团队带来一些麻烦。我们（这里我特指布拉德利·法里亚斯 推特@bradleymeck）已经试图去找出怎么去实现支持 Node.js 的 ECMAScript 模块（下面用 ESM 代指），才不会带来更多的疑惑和麻烦，使它更有价值。 真正的问题并不在于我们不能按照现在定义的 ES 标准去实现 Node.js 的 ESM，问题在于我们按照标准去做会不符合 Nodejs 开发者的预期，并且给他们带来不好的开发体验。我们非常想要确定 ESM 的实现能够是最佳优化和可用性强的。因为这个问题比较复杂，和 TC-39 的成员坐下来一起面对面讨论相信会是最有效的方式。幸运的是，我觉得我们取得了显著的进展。 为了使读者能够清楚问题所在，并且将要怎么解决，这里我花点时间解释下那个我们最关心的问题的基本所在。 首先，一个警告：接下来的内容对于透过代码里面详细的解释会比较简单，这里是因为这篇文章主要是提供一个综述，而不是一篇关于模块系统的深度剖析的论文。 其次，另一个警告：所有东西都是我对于 TC-39 这次会议的理解，很有可能我说的某些细节是错的，因为随着会议的进行，事情的进展可能会变得跟我这篇文章描述的不一样，这真的很有可能。我写这篇文章只是为了提供会议上被讨论的的东西的记录。 ECMSScript 模块 vs CommonJS：或者说…什么是模块？实际上，Node.js 和 TC-39 在什么是模块，怎么定义模块，模块怎么写进内存，模块怎么使用上面有非常不一样的意见。 在 Node.js 刚开始的时候，有一个从非常宽松定义的标准——叫 CommonJS，Node.js 的模块系统就是遵循它的标准的。 简要地说就是一个 JS 文件 export 的标识，比如函数或者变量，将可以被另外一个 JS 文件使用。在 Node.js 里面，这可以通过使用 require() 函数完成。当 Node.js 调用一个类似 require(‘foo’) 的时候，有一个非常特殊的队列步骤在进行。 第一步是把标识符 ‘foo’ 转换成 Node.js 能够读懂的绝对文件路径。这里的处理过程包括多步内部步骤，本质上就是去扫描本地文件系统去匹配对应的原生模块，JS 文件，JSON 文档。这个解析处理步骤的结果是产生一个 ‘foo’ 指定文件的能够被 Node.js 加载和使用的绝对文件路径。 接下来，加载完全取决于解析步骤产生的绝对文件路径指向什么。例如，如果解析地址指向的是 Node.js 原生模块，那就开始加载代码，这中间包括动态引入应用的 Node.js 共享库进入当前的 Node.js 进程。如果指向的是一个 JSON 文件或者 JS 文件，确认文件存在之后，文件的内容被读进内存里。这里应该重点注意加载 JS 代码和执行 JS 代码并不一样。前者只是严格的拉取文件的字符串内容进入内存，后者是将字符串传递给 JS 引擎解析和执行。 如果加载的是一个 JS 文件，Node.js 现在会假定文件是一个 CommonJS 模块。接下去，Node.js 做的是饱受争议并且许多 Node.js 应用的开发者也经常误解的。在把加载完的 JS 字符串传递给 JS 引擎解析之前，JS 代码被包裹在一个函数里面。 例如，一个 JS 文件 ‘foo.js’： 12const m = 1;module.exports.m = m; 事实上会被 Node.js 解析成为如下的函数： 1234function (exports, require, module, __filename, __dirname) &#123; const m = 1; module.exports.m = m;&#125; Node.js 使用 JS 运行环境来执行 JS 代码。很多全局的变量，比如 ‘exports’, ‘module’, ‘__filename’, ‘__dirname’，在 Node.js 常常被使用的，其实在 JS 的运行环境中并不是全局变量。当函数被调用时，Node.js 将这些函数作为参数传入包裹的函数。 包裹的函数本质上是一个工厂函数，exports 对象是一个普通的 JS 对象，包裹函数把对象和属性与 exports 函数连接起来。一旦包裹的函数产生返回值，exports 对象做了缓存，然后把值返回给 require() 函数。 理解这个讨论的关键概念在于，没有办法提前检测 CommonJS 模块 export 什么东西出来，直到包裹函数被执行后，才能直到确切是什么内容。 这是 CommonJS 模块和 ECMAScript 模块之间的显著区别。因为 CommonJS 模块的 exports 是在包裹函数被执行的时候定义的，而 ESM 的 exports 是语法上的定义。这意味着，当 JS 代码解析的时候，ESM 的 exports 标识已经被解析，就已经识别为 ESM，不用等到代码被执行的时候才能被判断。 例如，下面的这个简单的 ECMAScript 模块： 1export const m = 1; 当这段代码被解析的时候，在执行之前，就创建了一个内部的结构叫模块记录。在这个模块记录里面，记录着一些关键的数据，包括一个记录着模块 export 的标识的静态的列表。JS 解析器会通过寻找 export 关键字去识别。由于缺乏更好的表述，这里就说标识吧。模块记录的标识实质上指向的东西是还不存在的，因为代码还没有执行，只有模块记录建立好之后，模块的代码才真正的开始执行。这里面其实有很多细节，但我还是比较模糊不清，这里关键点就是，ESM 会在执行前去检测 export 出来的标识。 当使用 ECMAScript 模块时，它使用了一个 import 的语句： 1import &#123;m&#125; from “foo”; 这段代码主要讲，“我将要使用foo模块输出的m标识”。 这个语句是一个词法定义语句，当代码解析的时候，它用来建立 import 所在的脚本和 ‘foo’ 模块之间的连接。现在的ECMAScript 模块标准写着，这个连接必须在任何代码执行前生效，这意味着，模块的实现必须确保 ‘foo’ 模块确实有输出标识 ‘m’，这样两个 JS 文件才能被执行。 对于熟悉基于强对象的面向对象编程语言比如 Java 或者 C++ 的人来说，对模块的这么处理应该会觉得容易理解，因为它很想通过一个接口去访问对象。模块输出的标识会在执行前被确认和连接，如果有标识实现不完整，有错误，就会在执行阶段被抛出。 对于 Node.js 来说，这里有一个挑战，因为 ‘foo’ 模块并不是一个 ECMAScript 模块，是通过词法去定义 export 的，它是一个 CommonJS 模块，是动态去定义 export 的。具体来说，这里当我说，import {m} from “foo”，ECMAScript 模块现在需要在执行前检测 ‘foo’ 模块是否有输出标识 ‘m’。当时，就像我们知道的，因为 ‘foo’ 是一个 CommonJS 模块，这是不可能提前去检测的，因为执行后 m 才被输出。最终的结果就是，在现在定义的 ESM 标准下，ECMAScript 模块的很重要的一项功能，import 和 export，并不能 import CommonJS 模块。 这对于 Node.js 的开发者来说并不是很理想。所以我们回去 TC-39 问下是否能够在标准上面做些改变。起初，我们其实是有点害怕去问这个问题。但实际上，TC-39 很关心，并且也在标准上面正在做一些改表，以确保 Node.js 能够很好地实现 ECMAScript 模块，使得东西在 Node.js 环境下面运行得很好。 操作顺序一个被提议的确切的改变是对动态定义的模块做出说明。本质上，当我做出 import {m} from “foo” 这样的操作时，结果应该是返回 ‘foo’ 模块不是一个拥有 export 词法定义的 ECMAScript 模块，而不是像现在标准里面做的，直接抛出错误结束。进程应该把 ‘foo’ 模块和导入脚本进入一个待定状态，延迟验证动态模块导入的标识直到动态模块的代码能够被执行。一旦执行了代码，模块记录中关于 CommonJS 模块的就能完成，并且导入的链接也生效。这个 ECMAScript 模块标准的改进允许 export 和 import 的 CommonJS 模块能够工作。（虽然，这里关于循环依赖的边际案例还是会有一些坑存在） 我们通过一些例子来详细说明。 我有一个应用依赖于 ECMAScript 模块 A，A 模块依赖于 CommonJS 模块 B。 我的应用（myapp.js）的代码是 12const foo = require('A').defaultfoo() A 模块的代码是 1234import &#123;log&#125; from \"B\"export default function() &#123; log('hello world')&#125; B 模块的代码是 123module.exports.log = function(msg) &#123; console.log(msg);&#125; 当我运行 node myapp.js 的时候，调用 require(A) 会检测到加载的是一个 ECMAScript 模块（后面会解释这个是怎么完成的）。与 CommonJS 模块现在使用的包裹函数去加载模块不同，Node.js 会使用 ECMAScript 模块的标准去解析，初始化，和执行 A 模块。当 A 的代码解析后，就产生了模块记录，它会检测 B 不是一个 ECMAScript 模块，所以校验的步骤在校验 B 导出的日志之后，就会进入待定状态。ECMAScript 模块加载器就会开始它的执行阶段。这个阶段将首先使用现有的 CommonJS 包裹函数来执行 B 模块，其执行结果将传递回 ECMAScript 模块加载器，以完成模块记录的构造。其次，它将会根据完整的模块记录来执行 A 模块的代码。 关于交换依赖的顺序。就是 A 模块是一个 CommonJS 模块而 B 模块是一个 ECMAScript 模块。这里的话一切都工作正常，就像上面有插图的例子一样，ECMAScript 模块能够去 require() CommonJS 模块。 在绝大多数的使用场景下，这个加载模型是能够很好地运行的。但模块之间又循环依赖的时候，这里就开始有点麻烦了。那些之前使用过 CommonJS 模块循环依赖的人知道，当那些模块加载的顺序不同时有出现一些诡异的边际场景。同样的问题会在 CommonJS 模块和 ECMAScript 模块之间循环依赖的时候存在。 myapp.js 的代码保留和之前一样。但是，A 模块依赖于 B 模块，B 模块也依赖于 A 模块。 A 模块的代码是 123const b = require('B')exports.b = b.foo()exports.a = 1 B 模块的代码是 123module.exports.log = function(msg) &#123; console.log(msg);&#125; 当然这是一个相当特殊的人为举例的场景，主要是为了说明问题所在。这种循环变得非常不可能实现。当 ECMAScript 模块 B 被连接和执行后，&quot;a&quot; 标识仍然没有被定义和被 CommonJS 模块 A 导出。这种场景下应该被处理成一个引用错误。 但是，如果我们把 B 模块换成下面的代码： 12import A from “A”export foo () =&gt; A.a 这个循环依赖就能够正常工作，因为当一个 CommonJS 模块被使用一个 import 语句导入是，module.exports 变成 default 导出。这个场景下，ECMAScript 模块连接的是导出的 default 而非一个标识。 更简洁地说，指定命名标识的从 CommonJS 模块导入只有在 ECMAScript 模块和 CommonJS 模块之间没有循环依赖的时候才能正常工作。 另外一个由于 CommonJS 模块和 ECMAScript 模块之间不同导致的限制是，任何 CommonJS 模块在初始执行后的变化对于一个指定命名标识的导入来说并不可用。举个例子，加入 ECMAScript 模块 A 依赖于 CommonJS 模块 B。 假设 B 的代码如下 123module.exports.foo = function(name, key) &#123; module.exports[name] = key&#125; 当模块 B 被 模块 A 导入时，唯一导出的能够用来做命名引用的有效标识就是 default 和 foo。没有其他的标识会被加到 module.exports 上，当调用函数 foo 后，命名引用就开始生效了。它们通过 default 导出的话就会一直生效了。就像下面的代码一样，就会正常地工作了。 1234import &#123;foo&#125; from “B”import B from \"B\"foo(\"abc\", 123)if (B.abc === 123) &#123; /** ... **/ &#125; require() vs importrequire() 和 import 之间有一个非常清晰的区别：就是我们可以用 require() 来加载一个 ECMAScript 模块，也可以用 import 来导入一个 CommonJS 模块，但是却不可以在 CommonJS 模块里面用 import，同样的，require() 也默认不能在 ECMAScript 模块里面使用。 换句话说，如果我有一个 CommonJS 模块 A，那么下面的代码就是不能执行的，因为 import 语句不能再 CommonJS 模块里面使用： 12const b = require(‘B’)import c from \"C\" 如果你在 CommonJS 模块里面操作，正确的方式就是使用 require 去加载和使用一个 ECMAScript 模块： 12const b = require(‘B’)const c = require('C') 在一个 ECMAScript 模块里面，只有在特别地从原生导入之后，require() 才能生效和被使用。导入 require() 必须检测到特定的标识符，但是本质上它一般是这样的东西： 12import &#123;require&#125; from “nodejs”require(“foo”) 但是，因为能够直接通过 import 去导入一个 CommonJS 模块，所以只有非常少的情况下会去这么做。 另外一点：Node.js 成员有其他的一些想法，例如加载一个 ECMAScript 模块是否必须是异步的，因为这样会要求在整个依赖图表里面使用 Promise。TC-39 向我们保证（包括上面描述的改变也允许）加载不必须是异步的。这是一件好事。 import() 怎么样 在 TC-39 会议之前有一个提议提出来了，就是引进一个新的 import() 函数。这个就跟上面的例子里面的 import 语句展示的明显不一样了。看下下面的例子： 12import &#123;foo&#125; from “bar”import(“baz”).then((module)=&gt;&#123;/*…*/&#125;).catch((err)=&gt;&#123;/**…*/&#125;) 第一个 import 语句是词法上的定义。就像之前说的，它在代码解析的时候就已经被处理和确认。而 import() 函数不同，则是在运行代码的时候才被处理。它也可以 import ECMAScript 模块（或者 CommonJS 模块），但是，像现在 Node.js 里面的 require() 方法一样，完全在代码运行的时候执行。但不像 require() 函数，import() 函数返回一个 Promise，允许（但不要求）加载相关的模块完全异步地进行。 由于 import() 函数返回一个 Promise，像 await import(&#39;foo&#39;) 这样的代码就可能出现了。但是，很重要的是 import() 在 TC-39 内还远远没有完整，现在也还不成熟。同时，Node.js 能否完全实现使用 import() 函数异步加载模块也还不是很清楚。 检测CommonJS vs. ESM在代码是否使用 require(), import, import() 来加载模块前，很重要的是，要能够先检测导入的是什么类型的模块，这样 Node.js 才能够知道恰当的加载和处理它的方式。 按照惯例，Node.js require() 函数的实现是依赖于文件扩展名去区分怎么加载不同类型的文件。例如，*.node 文件被加载成原生模块，*.json 文件简单地通过 JSON.parse 传递，*.js 文件则被处理成 CommonJS 模块。 根据 ECMAScript 模块的介绍，需要一种机制来区分 CommonJS 模块和 ECMAScript 模块。这里有几种建议的方法。 一种方式是确保一个 JS 文件能够被清楚地解析成或者一个 ECMAScript 模块或者其他的东西，换句话说，当我解析一段 JS，它是不是一个 ESM 应该是非常显而易见的，这种方法叫做“无歧义文法”。不幸的是，它要实现会有点棘手。 另一种被考虑的方式是在 package.json 文件里面添加元数据。如果 package.json 文件里有一些特定的值，那么它将被加载成 ECMAScipt 模块，而不是 CommonJS 模块。 第三种方式是使用一种新的文件扩展名（*.mjs）来认定是 ECMAScript 模块。这种方式是最贴近于 Node.js 现在已经做的事情的。 例如，假设我有一个应用的代码 myapp.js 和一个定义在分离的文件的 ECMAScript 模块。 使用无歧义文法的方式，则 Node.js 需要能够去解析第二个文件的 JS 代码，并且自动判定它是使用 ECMAScript 模块。在这种方式中，ECMAScript 模块文件能够使用 *.js 文件扩展名，然后也能正常地运行。就像我说的，无歧义文法想要做的正确有点棘手，还有很多边际场景使得它很难实现。 使用 package.json 的方式，则 ECMAScript 模块必须被打包在它自己的目录里面（本质上是它自己的包）或者包的根目录必须有一个包含着一些元数据的 package.json 文件，元数据需要能够指明哪些 JS 包含着 ECMAScript 模块实际上是一个 ECMAScript 模块。这种方式不是很理想，因为需要对 package.json 文件做附加的操作。 使用 *.mjs 文件扩展名的方式，ECMAScript 模块的代码会被放进一个特定的文件例如 foo.mjs。在 Node.js 解析标识符成为文件的绝对路径后，它会开始查找文件的扩展名，就像现在它对原生扩展和 JSON 文件处理的一样。如果它判断是 *.mjs 文件扩展名，它就知道当做一个 ECMAScript 模块加载和处理。如果它判断是 *.js，就会降级处理加载成一个 CommonJS 模块。 幂等性的考量一般来说，重复调用 require(&#39;foo&#39;) 多次会返回完全相同的模块的实例。但是，返回的对象不是不可变的，它可以被其他模块更新，被一些方法或者标识补丁替换，甚至被替换整个函数。这种事情现在在 Node.js 生态圈中非常普遍存在。 例如，假设 myapp.js 有两个依赖 A 和 B。它们都是 CommonJS 模块。A 为了扩展它也依赖于 B。 myapp.js 的代码是： 123const A = require('A')const B = require('B')B.foo() A 的代码是： 123456const B = require(‘B’)const foo = B.fooB.foo = function() &#123; console.log('intercepted!') foo()&#125; B 的代码是： 123module.exports.foo = function() &#123; console.log('foo bar baz')&#125; 在这个案例里面，在 A 里面调用 require(&#39;B&#39;) 返回与 myapp.js 里面调用 require(&#39;B&#39;) 不一样的结果。 如果使用 ECMAScript 模块，这种模块间的互相干扰也不是很容易解决。理由是双重的：首先，引用是在运行前完成连接的；其次，引用需要是幂等性的——即在一个给定的上下文中，每次调用都会返回相同的不可变的标识。在实际情况下，这个意味着，当使用命名引用是，ES 模块 A 不能轻易地去改变 ES 模块 B。 这个规则对下面的 myapp.js 的代码有同样的影响： 1234const B = require('B')const foo = B.fooconst A = require('A')foo() 这里，A 模块依然更新 B 模块的函数 foo，但因为 foo 的引用已经在那个更新之前捕获了，调用函数 foo() 就是调用原来的函数而不失更新后的那个。在一个 ES 模块里面，没有办法能够引用能够被 A 更新过的模块 B。 这个幂等性的规则导致的问题还有很有其他各种各样的场景。mock，APM 和 为了测试的监控是最主要的例子。幸运的是，有很多方式能够去处理这种局限性。一种方式是增加加载阶段的钩子函数，允许一个 ES 模块的导出能够被包裹。另一个是让 TC-39 允许加载后的 ES 模块能够被替换。有几种机制在这里被考虑。好消息是拦截 ES 模块跟拦截 CommonJS 模块不一样，ES 模块能够被拦截。 还有很多要做还有一大堆工作要去做，上面讨论的任何东西在任何情况下都还不是最终定下来的。很多细节都要去解决，事情到最后看起来很可能会非常一样。重要的是 Node.js 和 TC-39 现在一起工作去解决所有的这些问题，这是在正确的方向上迈出的优秀的受欢迎的一步。 译者按 原文写于 2016 年 9 月份，今年 4 月份原文作者又写了一篇文章关于 Node.js 里的 ES 模块的一次更新——An Update on ES6 Modules in Node.js。当时译者准备对此文进行翻译但是凹凸实验室已经做了很好的翻译了，特此附上链接——【译】关于 Node.js 里 ES6 Modules 的一次更新说明。","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"//mervynfang.com/tags/FrontEnd/"},{"name":"Translation","slug":"Translation","permalink":"//mervynfang.com/tags/Translation/"}]},{"title":"Vue UI Framework 对比","date":"2017-04-17T01:15:35.000Z","path":"2017/04/17/201704/Vue-UI-Framework-对比/","text":"本文链接: http://blog.mervynfang.com/2017/04/17/201704/Vue-UI-Framework-%E5%AF%B9%E6%AF%94/ Vue 2.0 正式版之后，基于 1.x 的许多 Vue UI 框架都做了更新，以适配 Vue 2.x。当然其中也有一些并没有做升级，仍然只兼容 Vue 1.x。其中包括 vue UI 组件开始得比较早的 VueStrap （基于 bootsrap 的 UI 组件 ），还有 vue-antd（基于 ant-design），vue-desktop等。 这篇文章主要选择了 Github 开源社区并且兼容了 Vue 2.x 的 Star 较为多的进行比较，分别为 桌面端 element（star 8546） Keen-UI（star 2209） 移动端 vux（star 6512） mint-ui（star 4464） 其他的也有相对比较好的 UI 框架 比如 muse-ui 等，可以在 awesome-vue 查看。 UI Framework or Toolkit所谓 UI 框架，也可以说是 UI 的工具箱，利用已经现成的组件（比如输入框，提示，弹窗等）进行开发，不用去顾及设计规范，交互，api设计，页面展示样式，数据绑定，将大大提高项目的开发效率。虽然现有的 UI 框架所覆盖的组件类型已经非常广了，但是还是会存在高度定制化的组件存在，这时候也可以通过增加组件去扩展。而基于 vue 的 UI 框架更多的是解决了 vue 数据绑定的问题，使得我们可以只通过数据去控制 UI 的展示，而不需要去关注实现细节。 现行的 Vue UI Framework，基本上都做到了 api 简洁清晰，组件丰富，设计精美。在选择框架上，有的时候会考虑众多的因素，比如外观设计，社区的维护力度，或者个人偏好等。接下来将从框架的组件的功能以及技术设计方面浅析对比下 element 和 Keen-UI 以及 vux 和 mint-ui。 组件功能特点完善性桌面端上，element 是饿了么开发的。在 vue 2.0 还是 beta 版本时候就已经开源了，已经经过社区的一段时间的验证，并且 start 的数量也验证了 element 是一个优秀的 Vue UI 框架。Keen-UI 是社区出品，并没有中文文档，基于 Material Design 设计，较为轻量。 功能上，element 比 keen-UI 较为大，可以自定义外观主题，并且包含了布局的选择，内置了一套图标，总体上比较完善。element 实现了较为多的细节上的动画，交互看起来较为舒服，设计上保持了一致性。keen-ui 则遵循 Material Design 设计，主要实现组件，并不支持主题 icon 等的设置。二者都有较为丰富的组件，下列是 datepicker 组件的外观对比 element: keen-ui: 移动端上，vux 是 vue 与 weui 的结合，因为现有一套视觉规范，所以 vux 的组件的丰富度比较高，功能实现较为完善。并且也与微信原生视觉体验保持一致。而 mint-ui 也是饿了么开发，与 element 的视觉接近，功能点相较于并不是很完善。 vux 有 60 个功能组件，而 mint-ui 只有 30 个左右，所以总体上 vux 要更加强大一点。下面是二者的 swiper 外观对比： vux: mint-ui 可见 vux 实现的功能比 mint-ui 更加多，更加完善。 框架设计及开发api 设计上，因为这四个框架都已经挺完善的，只是在语义化上以及某些细节上有细微的差别，总体上还是设计得比较合理，通过文档 api 阅读便可快速进行开发。 在文档建设上面，element 做得更加好，每个组件的 example，api，source code 都是在同一个页面下，非常便于查阅，并且支持 jsfiddle 在线运行。很容易进行尝试。keen-ui 则做得相对比较差，source code 需要跳转到 github 文件查看。 移动端上，vux 文档做得比较全面，从配套的设施到组件文档都有涉及。mint-ui 主要是组件 example 介绍，可以在页面内体验移动端组件，做到了与 element 一致。vux 还有一个包括所有组件的总站，可以在手机端进行尝试，组件文档页面包括源码和 api，预览还是需要跳转。 引用方式上，四个框架都可以通过 CDN 或者 NPM 引入，并且都可以支持引入部分组件，并不需要都引入整个框架。 i18n 上，除了 keen-ui 外都有中英文文档，keen-ui 只有英文文档。当然，英语好没问题。国内的框架也都支持 i18n。 选择结论好吧结果，桌面端上，推荐使用 element，这是一个挺完善的项目，支持的功能多，社区繁荣，bug 解决得也快。 移动端上，推荐使用 vux。因为遵循着一套 weui 的规范，会使其看起来更加美观，设计也一致，mint-ui 在一些 logo 上还是会出现冲突。当然，如果产品的 PC 和 移动端要保持一致的话，又要使用社区的 UI 框架的话，那么 element 加 mint-ui 也未尝不是一个好的选择。 分享Vue UI Framework 文章Vue框架Element的事件传递broadcast和dispatch方法分析iView：一套基于 Vue 的高质量 UI 组件库 Element 一套优雅的 Vue 2 组件库是如何开发的 本周 Front End 好文 2017-02-17下一代 Web 应用模型 —— Progressive Web App2016年JavaScript领域中最受欢迎的“明星”们网易和淘宝移动WEB适配方案再分析","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"//mervynfang.com/tags/FrontEnd/"}]},{"title":"2017-04-16","date":"2017-04-16T14:04:48.000Z","path":"2017/04/16/201704/2017-04-16/","text":"本文链接: http://blog.mervynfang.com/2017/04/16/201704/2017-04-16/ 之前觉得，搞个 blog，虽然不难，但是一定有坑的，一定要改源码的。 没错，确实改了源码，不想去编译打包代码，直接在 dist 上面改，还是比较容易的。 无论如何，终于迁移到这里了。 之前的 qzone 说了，也便不再更新了。 昨晚看了歌手总决赛。一下子就五季了。五年前，是 2012 年，那时候，也刚好在准备高考了。难道是段足以回忆的历史吗。不觉得，可能，过来的不易，不想回去了吧。怀念，终究没啥用的。就类似惋惜，后悔，从来，也是没有任何作用的。 感觉张碧晨和杨宗纬唱得比较不错嘛。也可能是我喜欢歌吧。小岳岳也很不错，看到就想笑了。 难得能够放松的一个周末，其实也便没怎么放松，只是需要不断地前行吧。都不容易了。 今天也是 NBA 季后赛开打的时间，一个伟大的赛季，季后赛应该也该足够伟大。 所以，CP3 真的是很可惜了，戈贝尔受伤的情况下，还是被主场绝杀，那后面就没得打了。 所谓草木皆兵，快船还是少了点魂儿吧。 明天继续上班，感觉还是好多事情要做，可以做，一步一步慢慢来吧。 加油 mervynfang","tags":[{"name":"Daily","slug":"Daily","permalink":"//mervynfang.com/tags/Daily/"}]}]